Failed config

script: [source .esphome/packages/93553e33/epever_mppt_controller/loadcontrol.yaml:362]
  - id: update_nttv
    then: 
      - lambda: !lambda |-
          esphome::modbus_controller::ModbusController *controller = id(epever);
          
          std::vector<uint16_t> values = {
            (uint16_t)(id(x901e).state * 100),  // NTTV
            (uint16_t)(id(x901f).state),        // Delay 
            (uint16_t)(id(x9020).state * 100),  // DTTV
            (uint16_t)(id(x9021).state)         // Delay
          };
              
          esphome::modbus_controller::ModbusCommandItem cmd =
              esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(
                controller, 0x901e, values.size(), values
              );
          delay(200);
          controller->queue_command(cmd);
          
          delay(200);
          for(std::vector<uint16_t>::size_type i = 0; i != values.size(); i++) {
            ESP_LOGI("epever_mppt_controller", "NTTV %x: %d", i + 0x9000, values[i]);
          }
    mode: single
    parameters: {}
  - id: update_battery_params
    then: 
      - 
        Couldn't find ID 'reg9001'. Please check you have defined an ID with that name in your configuration. These IDs look similar: "reg900e", "reg900d", "reg900c".
        lambda: !lambda |-
          esphome::modbus_controller::ModbusController *controller = id(epever);
          
          std::vector<uint16_t> bat_params = {
            0,                                    // Battery Type User
            (uint16_t)(id(reg9001).state),        // Battery capacity (Ah)
            (uint16_t)(id(reg9002).state * 100),  // Temperature compensation coefficient
            (uint16_t)(id(reg9003).state * 100),  // Over voltage disconnect voltage (Load)
            (uint16_t)(id(reg9004).state * 100),  // Charging limit voltage (highest voltage the controller will allow charging)
            (uint16_t)(id(reg9005).state * 100),  // Over voltage reconnect voltage (Load)
            (uint16_t)(id(reg9006).state * 100),  // Equalize charging voltage
            (uint16_t)(id(reg9007).state * 100),  // Boost charging voltage
            (uint16_t)(id(reg9008).state * 100),  // Float charging voltage
            (uint16_t)(id(reg9009).state * 100),  // Boost reconnect charging voltage
            (uint16_t)(id(reg900a).state * 100),  // Low voltage reconnect voltage (load)
            (uint16_t)(id(reg900b).state * 100),  // Under voltage warning recover voltage
            (uint16_t)(id(reg900c).state * 100),  // Under voltage warning voltage
            (uint16_t)(id(reg900d).state * 100),  // Low voltage disconnect voltage (load)
            (uint16_t)(id(reg900e).state * 100)   // Discharging limit voltage (lowest voltage the controller will allow discharging)
          };
              
          esphome::modbus_controller::ModbusCommandItem write_bat_params =
              esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(
                controller, 0x9000, bat_params.size(), bat_params
              );
          delay(200);
          controller->queue_command(write_bat_params);
          delay(200);
          for(std::vector<uint16_t>::size_type i = 0; i != bat_params.size(); i++) {
            ESP_LOGI("epever_mppt_controller", "Battery Parameter %x: %d", i + 0x9000, bat_params[i]);
          }
          
          // Charge Timers
          std::vector<uint16_t> bat_timers = {
              (uint16_t)id(reg906b).state, // Equalize Duration
              (uint16_t)id(reg906c).state  // Boost Duration
          };
          esphome::modbus_controller::ModbusCommandItem write_bat_timers =
              esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(
                controller, 0x906b, bat_timers.size(), bat_timers
              );
          delay(200);
          controller->queue_command(write_bat_timers);
          delay(200);
          for(std::vector<uint16_t>::size_type i = 0; i != bat_timers.size(); i++) {
            ESP_LOGI("epever_mppt_controller", "Battery Timer %x: %d", i + 0x906b, bat_timers[i]);
          }
          
          ESP_LOGW("epever_mppt_controller", "Battery Parameters have been set!");
    mode: single
    parameters: {}
  - id: update_rtc
    then: 
      - lambda: !lambda |-
          auto now = id(sntp_time).now();
          
          if (!now.is_valid()) {
            ESP_LOGW("epever_mppt_controller", "RTC not valid yet. Skipping RTC Update.");
            return;
          }
          
          int s = now.second;
          int m = now.minute;
          int h = now.hour;
          int d = now.day_of_month;
          int M = now.month;
          int y = now.year % 100;
          
          uint16_t r1 = ((m << 8) | s);
          uint16_t r2 = ((d << 8) | h);
          uint16_t r3 = ((y << 8) | M);
          
          std::vector<uint16_t> rtc_data = {
            r1, r2, r3
          };
          
          for(std::vector<uint16_t>::size_type i = 0; i != rtc_data.size(); i++) {
            ESP_LOGI("epever_mppt_controller", "RTC Data to be sent: 0x%x: 0x%x", i + 0x9013, rtc_data[i]);
          }
          
          esphome::modbus_controller::ModbusController *controller = id(epever);
          esphome::modbus_controller::ModbusCommandItem cmd =
              esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(
                controller, 0x9013, 3, rtc_data
              );
          delay(200);
          controller->queue_command(cmd);
          delay(200);
          
          ESP_LOGI("epever_mppt_controller", "RTC updated to %04d-%02d-%02d %02d:%02d:%02d", y+2000, M, d, h, m, s);
    mode: single
    parameters: {}
